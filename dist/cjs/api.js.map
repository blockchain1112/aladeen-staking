{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"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","sourcesContent":["import { tryGetAccount } from \"@cardinal/common\";\nimport { BN } from \"@project-serum/anchor\";\nimport type { Wallet } from \"@project-serum/anchor/dist/cjs/provider\";\nimport type { Connection, PublicKey } from \"@solana/web3.js\";\nimport { Keypair, Transaction } from \"@solana/web3.js\";\n\nimport type {\n  GroupRewardDistributorKind,\n  GroupRewardDistributorMetadataKind,\n  GroupRewardDistributorPoolKind,\n} from \"./programs/groupRewardDistributor\";\nimport { getGroupRewardEntry } from \"./programs/groupRewardDistributor/accounts\";\nimport { findGroupRewardEntryId } from \"./programs/groupRewardDistributor/pda\";\nimport {\n  withClaimGroupRewards,\n  withCloseGroupRewardEntry,\n  withInitGroupRewardDistributor,\n  withInitGroupRewardEntry,\n  withUpdateGroupRewardDistributor,\n} from \"./programs/groupRewardDistributor/transaction\";\nimport type { RewardDistributorKind } from \"./programs/rewardDistributor\";\nimport { findRewardDistributorId } from \"./programs/rewardDistributor/pda\";\nimport {\n  withClaimRewards,\n  withInitRewardDistributor,\n  withInitRewardEntry,\n  withUpdateRewardEntry,\n} from \"./programs/rewardDistributor/transaction\";\nimport { ReceiptType } from \"./programs/stakePool\";\nimport {\n  getStakeEntries,\n  getStakeEntry,\n  getStakePool,\n} from \"./programs/stakePool/accounts\";\nimport {\n  withAddToGroupEntry,\n  withAuthorizeStakeEntry,\n  withClaimReceiptMint,\n  withInitGroupStakeEntry,\n  withInitStakeEntry,\n  withInitStakeMint,\n  withInitStakePool,\n  withInitUngrouping,\n  withRemoveFromGroupEntry,\n  withStake,\n  withUnstake,\n  withUpdateTotalStakeSeconds,\n} from \"./programs/stakePool/transaction\";\nimport { findStakeEntryIdFromMint } from \"./programs/stakePool/utils\";\nimport { getMintSupply } from \"./utils\";\n\n/**\n * Convenience call to create a stake pool\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param requiresCollections - (Optional) List of required collections pubkeys\n * @param requiresCreators - (Optional) List of required creators pubkeys\n * @param requiresAuthorization - (Optional) Boolean to require authorization\n * @param overlayText - (Optional) Text to overlay on receipt mint tokens\n * @param imageUri - (Optional) Image URI for stake pool\n * @param resetOnStake - (Optional) Boolean to reset an entry's total stake seconds on unstake\n * @param cooldownSeconds - (Optional) Number of seconds for token to cool down before returned to the staker\n * @param rewardDistributor - (Optional) Parameters to creat reward distributor\n * @returns\n */\nexport const createStakePool = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    requiresCollections?: PublicKey[];\n    requiresCreators?: PublicKey[];\n    requiresAuthorization?: boolean;\n    overlayText?: string;\n    imageUri?: string;\n    resetOnStake?: boolean;\n    cooldownSeconds?: number;\n    minStakeSeconds?: number[];\n    endDate?: BN;\n    doubleOrResetEnabled?: boolean;\n    rewardDistributors?: {\n      duration: number;\n      rewardMintId: PublicKey;\n      rewardAmount?: BN;\n      rewardDurationSeconds?: BN;\n      rewardDistributorKind?: RewardDistributorKind;\n      maxSupply?: BN;\n      supply?: BN;\n      stakePoolDuration: number;\n    }[];\n    taxMint: PublicKey;\n    offset?: number;\n  }\n): Promise<[Transaction[], PublicKey, (number | PublicKey)[][]?]> => {\n  const transaction = new Transaction();\n  const rewardTransaction = new Transaction();\n\n  const [, stakePoolId] = await withInitStakePool(\n    transaction,\n    connection,\n    wallet,\n    params\n  );\n  let rewardDistributorIds = [];\n\n  if (params.rewardDistributors) {\n    let rewardMintTokenAccountCreationRecord: { [mint: string]: boolean } =\n      params.rewardDistributors!.reduce(\n        (acc, _dist) => ({ ...acc, [_dist.rewardMintId.toString()]: false }),\n        {}\n      );\n    for (const [\n      index,\n      rewardDistributor,\n    ] of params.rewardDistributors.entries()) {\n      const [, rewardDistributorId] = await withInitRewardDistributor(\n        rewardTransaction,\n        connection,\n        wallet,\n        {\n          distributorId: new BN(index),\n          stakePoolId: stakePoolId,\n          rewardMintId: rewardDistributor.rewardMintId,\n          rewardAmount: rewardDistributor.rewardAmount,\n          rewardDurationSeconds: rewardDistributor.rewardDurationSeconds,\n          kind: rewardDistributor.rewardDistributorKind,\n          maxSupply: rewardDistributor.maxSupply,\n          supply: rewardDistributor.supply,\n          stakePoolDuration: rewardDistributor.duration,\n          createRewardDistributorMintTokenAccount:\n            !rewardMintTokenAccountCreationRecord[\n            rewardDistributor.rewardMintId.toString()\n            ],\n        }\n      );\n      rewardMintTokenAccountCreationRecord[\n        rewardDistributor.rewardMintId.toString()\n      ] = true;\n\n      rewardDistributorIds.push([\n        new BN(index).toNumber(),\n        rewardDistributorId,\n      ]);\n    }\n  }\n  return [[transaction, rewardTransaction], stakePoolId, rewardDistributorIds];\n};\n\n/**\n * Convenience call to create a reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param rewardMintId - (Optional) Reward mint id\n * @param rewardAmount - (Optional) Reward amount\n * @param rewardDurationSeconds - (Optional) Reward duration in seconds\n * @param rewardDistributorKind - (Optional) Reward distributor kind Mint or Treasury\n * @param maxSupply - (Optional) Max supply\n * @param supply - (Optional) Supply\n * @returns\n */\nexport const createRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorId: BN;\n    stakePoolId: PublicKey;\n    rewardMintId: PublicKey;\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    kind?: RewardDistributorKind;\n    maxSupply?: BN;\n    supply?: BN;\n    stakePoolDuration: number;\n  }\n): Promise<[Transaction, PublicKey]> =>\n  withInitRewardDistributor(new Transaction(), connection, wallet, params);\n\n/**\n * Convenience call to create a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @param user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @returns\n */\nexport const createStakeEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n  }\n): Promise<[Transaction, PublicKey]> => {\n  return withInitStakeEntry(new Transaction(), connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    originalMintId: params.originalMintId,\n  });\n};\n\n/**\n * Convenience call to create a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const initializeRewardEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorId: BN;\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    multiplier?: BN;\n    duration: number;\n  }\n): Promise<Transaction> => {\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    params.stakePoolId,\n    params.originalMintId\n  );\n  const stakeEntryData = await tryGetAccount(() =>\n    getStakeEntry(connection, stakeEntryId)\n  );\n\n  const transaction = new Transaction();\n  if (!stakeEntryData) {\n    await withInitStakeEntry(transaction, connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      originalMintId: params.originalMintId,\n    });\n  }\n\n  const rewardDistributorId = findRewardDistributorId(\n    params.stakePoolId,\n    params.distributorId,\n    params.duration\n  );\n  await withInitRewardEntry(transaction, connection, wallet, {\n    stakeEntryId: stakeEntryId,\n    rewardDistributorId: rewardDistributorId,\n  });\n\n  await withUpdateRewardEntry(transaction, connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    rewardDistributorId: rewardDistributorId,\n    stakeEntryId: stakeEntryId,\n    multiplier: params.multiplier ?? new BN(1), //TODO default multiplier\n  });\n  return transaction;\n};\n\n/**\n * Convenience call to authorize a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const authorizeStakeEntry = (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n  }\n) => {\n  return withAuthorizeStakeEntry(new Transaction(), connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    originalMintId: params.originalMintId,\n  });\n};\n\n/**\n * Convenience call to create a stake entry and a stake mint\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @param amount - (Optional) Amount of tokens to be staked, defaults to 1\n * @returns\n */\nexport const createStakeEntryAndStakeMint = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    receiptName?: string;\n  }\n): Promise<[Transaction, PublicKey, Keypair | undefined]> => {\n  let transaction = new Transaction();\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    params.stakePoolId,\n    params.originalMintId\n  );\n  const stakeEntryData = await tryGetAccount(() =>\n    getStakeEntry(connection, stakeEntryId)\n  );\n  if (!stakeEntryData) {\n    transaction = (\n      await createStakeEntry(connection, wallet, {\n        stakePoolId: params.stakePoolId,\n        originalMintId: params.originalMintId,\n      })\n    )[0];\n  }\n\n  let stakeMintKeypair: Keypair | undefined;\n  if (!stakeEntryData?.parsed.stakeMint) {\n    stakeMintKeypair = Keypair.generate();\n    const stakePool = await getStakePool(connection, params.stakePoolId);\n\n    await withInitStakeMint(transaction, connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      stakeEntryId: stakeEntryId,\n      originalMintId: params.originalMintId,\n      stakeMintKeypair,\n      name:\n        params.receiptName ??\n        `POOl${stakePool.parsed.identifier.toString()} RECEIPT`,\n      symbol: `POOl${stakePool.parsed.identifier.toString()}`,\n    });\n  }\n\n  return [transaction, stakeEntryId, stakeMintKeypair];\n};\n\n/**\n * Convenience method to claim rewards\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool id\n * @param stakeEntryId - Original mint id\n * @returns\n */\nexport const claimRewards = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorId: BN;\n    stakePoolId: PublicKey;\n    stakeEntryId: PublicKey;\n    lastStaker?: PublicKey;\n    payer?: PublicKey;\n    skipRewardMintTokenAccount?: boolean;\n    authority?: PublicKey;\n    stakePoolDuration: number;\n  }\n): Promise<Transaction> => {\n  const transaction = new Transaction();\n\n  await withUpdateTotalStakeSeconds(transaction, connection, wallet, {\n    stakeEntryId: params.stakeEntryId,\n    lastStaker: wallet.publicKey,\n  });\n\n  await withClaimRewards(transaction, connection, wallet, {\n    distributorId: params.distributorId,\n    stakePoolId: params.stakePoolId,\n    stakeEntryId: params.stakeEntryId,\n    lastStaker: params.lastStaker ?? wallet.publicKey,\n    payer: params.payer,\n    skipRewardMintTokenAccount: params.skipRewardMintTokenAccount,\n    authority: params.authority,\n    stakePoolDuration: params.stakePoolDuration,\n  });\n\n  return transaction;\n};\n\n/**\n * Convenience method to stake tokens\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool id\n * @param originalMintId - Original mint id\n * @param userOriginalMintTokenAccountId - User's original mint token account id\n * @param receiptType - (Optional) ReceiptType to be received back. If none provided, none will be claimed\n * @param user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @param amount - (Optional) Amount of tokens to be staked, defaults to 1\n * @returns\n */\nexport const stake = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    userOriginalMintTokenAccountId: PublicKey;\n    receiptType?: ReceiptType;\n    amount?: BN;\n  }\n): Promise<Transaction> => {\n  const supply = await getMintSupply(connection, params.originalMintId);\n  if (\n    (supply.gt(new BN(1)) || params.amount?.gt(new BN(1))) &&\n    params.receiptType === ReceiptType.Original\n  ) {\n    throw new Error(\"Fungible with receipt type Original is not supported yet\");\n  }\n\n  let transaction = new Transaction();\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    params.stakePoolId,\n    params.originalMintId\n  );\n  const stakeEntryData = await tryGetAccount(() =>\n    getStakeEntry(connection, stakeEntryId)\n  );\n  if (!stakeEntryData) {\n    [transaction] = await createStakeEntry(connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      originalMintId: params.originalMintId,\n    });\n  }\n\n  await withStake(transaction, connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    originalMintId: params.originalMintId,\n    userOriginalMintTokenAccountId: params.userOriginalMintTokenAccountId,\n    amount: params.amount,\n    duration: 0,\n  });\n\n  if (params.receiptType && params.receiptType !== ReceiptType.None) {\n    const receiptMintId =\n      params.receiptType === ReceiptType.Receipt\n        ? stakeEntryData?.parsed.stakeMint\n        : params.originalMintId;\n    if (!receiptMintId) {\n      throw new Error(\n        \"Stake entry has no stake mint. Initialize stake mint first.\"\n      );\n    }\n    if (\n      stakeEntryData?.parsed.stakeMintClaimed ||\n      stakeEntryData?.parsed.originalMintClaimed\n    ) {\n      throw new Error(\"Receipt has already been claimed.\");\n    }\n\n    if (\n      !stakeEntryData?.parsed ||\n      stakeEntryData.parsed.amount.toNumber() === 0\n    ) {\n      await withClaimReceiptMint(transaction, connection, wallet, {\n        stakePoolId: params.stakePoolId,\n        stakeEntryId: stakeEntryId,\n        originalMintId: params.originalMintId,\n        receiptMintId: receiptMintId,\n        receiptType: params.receiptType,\n      });\n    }\n  }\n\n  return transaction;\n};\n\n/**\n * Convenience method to unstake tokens\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const unstake = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorIds: BN[];\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    skipRewardMintTokenAccount?: boolean;\n    stakePoolDuration: number;\n  }\n): Promise<Transaction> =>\n  withUnstake(new Transaction(), connection, wallet, params);\n\n/**\n * Convenience call to create a group entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * stakePoolId - Stake pool ID\n * originalMintId - Original mint ID\n * user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @returns\n */\nexport const createGroupEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakeEntryIds: PublicKey[];\n    groupCooldownSeconds?: number;\n    groupStakeSeconds?: number;\n  }\n): Promise<[Transaction, PublicKey]> => {\n  if (!params.stakeEntryIds.length) throw new Error(\"No stake entry found\");\n  const [transaction, groupEntryId] = await withInitGroupStakeEntry(\n    new Transaction(),\n    connection,\n    wallet,\n    {\n      groupCooldownSeconds: params.groupCooldownSeconds,\n      groupStakeSeconds: params.groupStakeSeconds,\n    }\n  );\n\n  await Promise.all(\n    params.stakeEntryIds.map((stakeEntryId) =>\n      withAddToGroupEntry(transaction, connection, wallet, {\n        groupEntryId,\n        stakeEntryId,\n      })\n    )\n  );\n\n  return [transaction, groupEntryId];\n};\n\n/**\n * Convenience call to create a group reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n *  rewardMintId - (Optional) Reward mint id\n *  authorizedPools - Authorized stake pool ids\n *  rewardAmount - (Optional) Reward amount\n *  rewardDurationSeconds - (Optional) Reward duration in seconds\n *  rewardKind - (Optional) Reward distributor kind Mint or Treasury\n *  poolKind - (Optional) Reward distributor pool validation kind NoRestriction, AllFromSinglePool or EachFromSeparatePool\n *  metadataKind - (Optional) Reward distributor metadata validation kind NoRestriction, UniqueNames or UniqueSymbols\n *  supply - (Optional) Supply\n *  baseAdder - (Optional) Base adder value that will be add to the calculated multiplier\n *  baseAdderDecimals - (Optional) Base adder decimals\n *  baseMultiplier - (Optional) Base multiplier value that will be multiplied by the calculated multiplier\n *  baseMultiplierDecimals - (Optional) Base multiplier decimals\n *  multiplierDecimals - (Optional) Multiplier decimals\n *  maxSupply - (Optional) Max supply\n *  minCooldownSeconds - (Optional) number;\n *  minStakeSeconds - (Optional) number;\n *  groupCountMultiplier - (Optional) Group Count Multiplier if provided will multiplied the total reward to this number and total groups that this user has\n *  groupCountMultiplierDecimals - (Optional) Group Count Multiplier decimals\n *  minGroupSize - (Optional) min group size\n *  maxRewardSecondsReceived - (Optional) max reward seconds received\n * @returns\n */\nexport const createGroupRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    rewardMintId: PublicKey;\n    authorizedPools: PublicKey[];\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    rewardKind?: GroupRewardDistributorKind;\n    poolKind?: GroupRewardDistributorPoolKind;\n    metadataKind?: GroupRewardDistributorMetadataKind;\n    supply?: BN;\n    baseAdder?: BN;\n    baseAdderDecimals?: number;\n    baseMultiplier?: BN;\n    baseMultiplierDecimals?: number;\n    multiplierDecimals?: number;\n    maxSupply?: BN;\n    minCooldownSeconds?: number;\n    minStakeSeconds?: number;\n    groupCountMultiplier?: BN;\n    groupCountMultiplierDecimals?: number;\n    minGroupSize?: number;\n    maxRewardSecondsReceived?: BN;\n  }\n): Promise<[Transaction, PublicKey]> =>\n  withInitGroupRewardDistributor(new Transaction(), connection, wallet, params);\n\n/**\n * Convenience call to update a group reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor id\n * authorizedPools - Authorized stake pool ids\n * rewardAmount - (Optional) Reward amount\n * rewardDurationSeconds - (Optional) Reward duration in seconds\n * poolKind - (Optional) Reward distributor pool validation kind NoRestriction, AllFromSinglePool or EachFromSeparatePool\n * metadataKind - (Optional) Reward distributor metadata validation kind NoRestriction, UniqueNames or UniqueSymbols\n * baseAdder - (Optional) Base adder value that will be add to the calculated multiplier\n * baseAdderDecimals - (Optional) Base adder decimals\n * baseMultiplier - (Optional) Base multiplier value that will be multiplied by the calculated multiplier\n * baseMultiplierDecimals - (Optional) Base multiplier decimals\n * multiplierDecimals - (Optional) Multiplier decimals\n * maxSupply - (Optional) Max supply\n * minCooldownSeconds - (Optional) number;\n * minStakeSeconds - (Optional) number;\n * groupCountMultiplier - (Optional) Group Count Multiplier if provided will multiplied the total reward to this number and total groups that this user has\n * groupCountMultiplierDecimals - (Optional) Group Count Multiplier decimals\n * minGroupSize - (Optional) min group size\n * maxRewardSecondsReceived - (Optional) max reward seconds received\n * @returns\n */\nexport const updateGroupRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupRewardDistributorId: PublicKey;\n    authorizedPools: PublicKey[];\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    poolKind?: GroupRewardDistributorPoolKind;\n    metadataKind?: GroupRewardDistributorMetadataKind;\n    baseAdder?: BN;\n    baseAdderDecimals?: number;\n    baseMultiplier?: BN;\n    baseMultiplierDecimals?: number;\n    multiplierDecimals?: number;\n    maxSupply?: BN;\n    minCooldownSeconds?: number;\n    minStakeSeconds?: number;\n    groupCountMultiplier?: BN;\n    groupCountMultiplierDecimals?: number;\n    minGroupSize?: number;\n    maxRewardSecondsReceived?: BN;\n  }\n): Promise<Transaction> =>\n  withUpdateGroupRewardDistributor(\n    new Transaction(),\n    connection,\n    wallet,\n    params\n  );\n\n/**\n * Convenience method to claim rewards\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const claimGroupRewards = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorId: BN;\n    groupRewardDistributorId: PublicKey;\n    groupEntryId: PublicKey;\n    stakeEntryIds: PublicKey[];\n  }\n): Promise<[Transaction]> => {\n  const transaction = new Transaction();\n\n  const groupRewardEntryId = findGroupRewardEntryId(\n    params.groupRewardDistributorId,\n    params.groupEntryId\n  );\n\n  const groupRewardEntry = await tryGetAccount(() =>\n    getGroupRewardEntry(connection, groupRewardEntryId)\n  );\n  if (!groupRewardEntry) {\n    const stakeEntriesData = await getStakeEntries(\n      connection,\n      params.stakeEntryIds\n    );\n\n    const stakeEntries = await Promise.all(\n      stakeEntriesData.map((stakeEntry) => {\n        const rewardDistributorId = findRewardDistributorId(\n          stakeEntry.parsed.pool,\n          params.distributorId,\n          0\n        );\n        return {\n          stakeEntryId: stakeEntry.pubkey,\n          originalMint: stakeEntry.parsed.originalMint,\n          rewardDistributorId,\n        };\n      })\n    );\n\n    await withInitGroupRewardEntry(transaction, connection, wallet, {\n      groupRewardDistributorId: params.groupRewardDistributorId,\n      groupEntryId: params.groupEntryId,\n      stakeEntries,\n    });\n  }\n\n  await withClaimGroupRewards(transaction, connection, wallet, {\n    groupRewardDistributorId: params.groupRewardDistributorId,\n    groupEntryId: params.groupEntryId,\n  });\n\n  return [transaction];\n};\n\n/**\n * Convenience method to close group stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const closeGroupEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    distributorId: BN;\n    groupRewardDistributorId: PublicKey;\n    groupEntryId: PublicKey;\n    stakeEntryIds: PublicKey[];\n  }\n): Promise<[Transaction]> => {\n  const [transaction] = await claimGroupRewards(connection, wallet, params);\n\n  await withCloseGroupRewardEntry(transaction, connection, wallet, {\n    groupEntryId: params.groupEntryId,\n    groupRewardDistributorId: params.groupRewardDistributorId,\n  });\n\n  await Promise.all(\n    params.stakeEntryIds.map((stakeEntryId) =>\n      withRemoveFromGroupEntry(transaction, connection, wallet, {\n        groupEntryId: params.groupEntryId,\n        stakeEntryId,\n      })\n    )\n  );\n  return [transaction];\n};\n\n/**\n * Convenience method to init ungrouping\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const initUngrouping = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupEntryId: PublicKey;\n  }\n): Promise<[Transaction]> => {\n  const transaction = new Transaction();\n\n  await withInitUngrouping(transaction, connection, wallet, {\n    groupEntryId: params.groupEntryId,\n  });\n\n  return [transaction];\n};\n"]}